<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- bootstrap library and JS, Jquery -->
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css"
    integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
  <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js"
    integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo"
    crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js"
    integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1"
    crossorigin="anonymous"></script>
  <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"
    integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM"
    crossorigin="anonymous"></script><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>SOLID Principles | KaizenThink</title>
<meta name="generator" content="Jekyll v4.2.1" />
<meta property="og:title" content="SOLID Principles" />
<meta name="author" content="Duc Nguyen" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="The SOLID Principles are five principles of Object-Oriented class design. They are a set of rules and best practices to follow while designing a class structure. These five principles help us understand the need for certain design patterns and software architecture in general. Following the SOLID acronym, they are: THE SINGLE RESPONSIBILITY PRINCIPLE THE OPEN-CLOSED PRINCIPLE LISKOV SUBSTITUTION PRINCIPLE INTERFACE SEGREGATION PRINCIPLE DEPENDENCY INVERSION PRINCIPLE More information THE SINGLE RESPONSIBILITY PRINCIPLE The Single Responsibility Principle states that a class should do one thing and therefore it should have only a single reason to change. Example: Let’s consider a class that contains code that changes the text in some way. The only job of this class should be manipulating text. Although this may seem fine, it is not a good example of the SRP. Here we have two responsibilities: manipulating and printing the text. public class TextManipulator { private String text; public TextManipulator(String text) { this.text = text; } public String getText() { return text; } public void appendText(String newText) { text = text.concat(newText); } public String findWordAndReplace(String word, String replacementWord) { if (text.contains(word)) { text = text.replace(word, replacementWord); } return text; } public String findWordAndDelete(String word) { if (text.contains(word)) { text = text.replace(word, &quot;&quot;); } return text; } public void printText() { System.out.println(textManipulator.getText()); } } Having a method that prints out text in this class violate the Single Responsibility Principle. For this purpose, we should create another class, which will only handle printing text: public class TextPrinter { TextManipulator textManipulator; public TextPrinter(TextManipulator textManipulator) { this.textManipulator = textManipulator; } public void printText() { System.out.println(textManipulator.getText()); } public void printOutEachWordOfText() { System.out.println(Arrays.toString(textManipulator.getText() .split(&quot; &quot;))); } public void printRangeOfCharacters(int startingIndex, int endIndex) { System.out.println(textManipulator.getText().substring(startingIndex, endIndex)); } } Let’s go back to our TextManipulator class methods: public class TextManipulator { private String text; public TextManipulator(String text) { this.text = text; } public String getText() { return text; } public void appendText(String newText) { text = text.concat(newText); } public String findWordAndReplace(String word, String replacementWord) { if (text.contains(word)) { text = text.replace(word, replacementWord); } return text; } public String findWordAndDelete(String word) { if (text.contains(word)) { text = text.replace(word, &quot;&quot;); } return text; } } THE OPEN-CLOSED PRINCIPLE The Open-Closed Principle requires that classes should be open for extension and closed to modification. Modification means changing the code of an existing class, and extension means adding new functionality. Example with non open-closed principle public class HealthInsuranceSurveyor{ public boolean isValidClaim(){ System.out.println(&quot;HealthInsuranceSurveyor: Validating health insurance claim...&quot;); /*Logic to validate health insurance claims*/ return true; } } public class ClaimApprovalManager { public void processHealthClaim (HealthInsuranceSurveyor surveyor) { if(surveyor.isValidClaim()){ System.out.println(&quot;ClaimApprovalManager: Valid claim. Currently processing claim for approval....&quot;); } } } /** Both the HealthInsuranceSurveyor and ClaimApprovalManager classes work fine and the design for the insurance system appears perfect until a new requirement to process vehicle insurance claims arises. We now need to include a new VehicleInsuranceSurveyor class, and this should not create any problems. But, what we also need is to modify the ClaimApprovalManager class to process vehicle insurance claims. This is how the modified ClaimApprovalManager will be: **/ public class ClaimApprovalManager { public void processHealthClaim (HealthInsuranceSurveyor surveyor) { if(surveyor.isValidClaim()){ System.out.println(&quot;ClaimApprovalManager: Valid claim. Currently processing claim for approval....&quot;); } } public void processVehicleClaim (VehicleInsuranceSurveyor surveyor) { if(surveyor.isValidClaim()){ System.out.println(&quot;ClaimApprovalManager: Valid claim. Currently processing claim for approval....&quot;); } } } Example with applying open-closed principle public abstract class InsuranceSurveyor { public abstract boolean isValidClaim(); } public class HealthInsuranceSurveyor extends InsuranceSurveyor{ public boolean isValidClaim(){ System.out.println(&quot;HealthInsuranceSurveyor: Validating health insurance claim...&quot;); /*Logic to validate health insurance claims*/ return true; } } public class VehicleInsuranceSurveyor extends InsuranceSurveyor{ public boolean isValidClaim(){ System.out.println(&quot;VehicleInsuranceSurveyor: Validating vehicle insurance claim...&quot;); /*Logic to validate vehicle insurance claims*/ return true; } } public class ClaimApprovalManager { public void processClaim(InsuranceSurveyor surveyor) { if(surveyor.isValidClaim()){ System.out.println(&quot;ClaimApprovalManager: Valid claim. Currently processing claim for approval....&quot;); } } } public class ClaimApprovalManagerTest { @Test public void testProcessClaim() throws Exception { HealthInsuranceSurveyor healthInsuranceSurveyor=new HealthInsuranceSurveyor(); ClaimApprovalManager claim1=new ClaimApprovalManager(); claim1.processClaim(healthInsuranceSurveyor); VehicleInsuranceSurveyor vehicleInsuranceSurveyor=new VehicleInsuranceSurveyor(); ClaimApprovalManager claim2=new ClaimApprovalManager(); claim2.processClaim(vehicleInsuranceSurveyor); } } LISKOV SUBSTITUTION PRINCIPLE The Liskov Substitution Principle states that subclasses should be substitutable for their base classes. INTERFACE SEGREGATION PRINCIPLE Segregation means keeping things separated, and the Interface Segregation Principle is about separating the interfaces. The principle states that many client-specific interfaces are better than one general-purpose interface. Clients should not be forced to implement a function they do no need. DEPENDENCY INVERSION PRINCIPLE The Dependency Inversion principle states that our classes should depend upon interfaces or abstract classes instead of concrete classes and functions." />
<meta property="og:description" content="The SOLID Principles are five principles of Object-Oriented class design. They are a set of rules and best practices to follow while designing a class structure. These five principles help us understand the need for certain design patterns and software architecture in general. Following the SOLID acronym, they are: THE SINGLE RESPONSIBILITY PRINCIPLE THE OPEN-CLOSED PRINCIPLE LISKOV SUBSTITUTION PRINCIPLE INTERFACE SEGREGATION PRINCIPLE DEPENDENCY INVERSION PRINCIPLE More information THE SINGLE RESPONSIBILITY PRINCIPLE The Single Responsibility Principle states that a class should do one thing and therefore it should have only a single reason to change. Example: Let’s consider a class that contains code that changes the text in some way. The only job of this class should be manipulating text. Although this may seem fine, it is not a good example of the SRP. Here we have two responsibilities: manipulating and printing the text. public class TextManipulator { private String text; public TextManipulator(String text) { this.text = text; } public String getText() { return text; } public void appendText(String newText) { text = text.concat(newText); } public String findWordAndReplace(String word, String replacementWord) { if (text.contains(word)) { text = text.replace(word, replacementWord); } return text; } public String findWordAndDelete(String word) { if (text.contains(word)) { text = text.replace(word, &quot;&quot;); } return text; } public void printText() { System.out.println(textManipulator.getText()); } } Having a method that prints out text in this class violate the Single Responsibility Principle. For this purpose, we should create another class, which will only handle printing text: public class TextPrinter { TextManipulator textManipulator; public TextPrinter(TextManipulator textManipulator) { this.textManipulator = textManipulator; } public void printText() { System.out.println(textManipulator.getText()); } public void printOutEachWordOfText() { System.out.println(Arrays.toString(textManipulator.getText() .split(&quot; &quot;))); } public void printRangeOfCharacters(int startingIndex, int endIndex) { System.out.println(textManipulator.getText().substring(startingIndex, endIndex)); } } Let’s go back to our TextManipulator class methods: public class TextManipulator { private String text; public TextManipulator(String text) { this.text = text; } public String getText() { return text; } public void appendText(String newText) { text = text.concat(newText); } public String findWordAndReplace(String word, String replacementWord) { if (text.contains(word)) { text = text.replace(word, replacementWord); } return text; } public String findWordAndDelete(String word) { if (text.contains(word)) { text = text.replace(word, &quot;&quot;); } return text; } } THE OPEN-CLOSED PRINCIPLE The Open-Closed Principle requires that classes should be open for extension and closed to modification. Modification means changing the code of an existing class, and extension means adding new functionality. Example with non open-closed principle public class HealthInsuranceSurveyor{ public boolean isValidClaim(){ System.out.println(&quot;HealthInsuranceSurveyor: Validating health insurance claim...&quot;); /*Logic to validate health insurance claims*/ return true; } } public class ClaimApprovalManager { public void processHealthClaim (HealthInsuranceSurveyor surveyor) { if(surveyor.isValidClaim()){ System.out.println(&quot;ClaimApprovalManager: Valid claim. Currently processing claim for approval....&quot;); } } } /** Both the HealthInsuranceSurveyor and ClaimApprovalManager classes work fine and the design for the insurance system appears perfect until a new requirement to process vehicle insurance claims arises. We now need to include a new VehicleInsuranceSurveyor class, and this should not create any problems. But, what we also need is to modify the ClaimApprovalManager class to process vehicle insurance claims. This is how the modified ClaimApprovalManager will be: **/ public class ClaimApprovalManager { public void processHealthClaim (HealthInsuranceSurveyor surveyor) { if(surveyor.isValidClaim()){ System.out.println(&quot;ClaimApprovalManager: Valid claim. Currently processing claim for approval....&quot;); } } public void processVehicleClaim (VehicleInsuranceSurveyor surveyor) { if(surveyor.isValidClaim()){ System.out.println(&quot;ClaimApprovalManager: Valid claim. Currently processing claim for approval....&quot;); } } } Example with applying open-closed principle public abstract class InsuranceSurveyor { public abstract boolean isValidClaim(); } public class HealthInsuranceSurveyor extends InsuranceSurveyor{ public boolean isValidClaim(){ System.out.println(&quot;HealthInsuranceSurveyor: Validating health insurance claim...&quot;); /*Logic to validate health insurance claims*/ return true; } } public class VehicleInsuranceSurveyor extends InsuranceSurveyor{ public boolean isValidClaim(){ System.out.println(&quot;VehicleInsuranceSurveyor: Validating vehicle insurance claim...&quot;); /*Logic to validate vehicle insurance claims*/ return true; } } public class ClaimApprovalManager { public void processClaim(InsuranceSurveyor surveyor) { if(surveyor.isValidClaim()){ System.out.println(&quot;ClaimApprovalManager: Valid claim. Currently processing claim for approval....&quot;); } } } public class ClaimApprovalManagerTest { @Test public void testProcessClaim() throws Exception { HealthInsuranceSurveyor healthInsuranceSurveyor=new HealthInsuranceSurveyor(); ClaimApprovalManager claim1=new ClaimApprovalManager(); claim1.processClaim(healthInsuranceSurveyor); VehicleInsuranceSurveyor vehicleInsuranceSurveyor=new VehicleInsuranceSurveyor(); ClaimApprovalManager claim2=new ClaimApprovalManager(); claim2.processClaim(vehicleInsuranceSurveyor); } } LISKOV SUBSTITUTION PRINCIPLE The Liskov Substitution Principle states that subclasses should be substitutable for their base classes. INTERFACE SEGREGATION PRINCIPLE Segregation means keeping things separated, and the Interface Segregation Principle is about separating the interfaces. The principle states that many client-specific interfaces are better than one general-purpose interface. Clients should not be forced to implement a function they do no need. DEPENDENCY INVERSION PRINCIPLE The Dependency Inversion principle states that our classes should depend upon interfaces or abstract classes instead of concrete classes and functions." />
<link rel="canonical" href="/java/2021/03/11/solid-principles.html" />
<meta property="og:url" content="/java/2021/03/11/solid-principles.html" />
<meta property="og:site_name" content="KaizenThink" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-03-11T00:00:00+07:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="SOLID Principles" />
<script type="application/ld+json">
{"mainEntityOfPage":{"@type":"WebPage","@id":"/java/2021/03/11/solid-principles.html"},"@type":"BlogPosting","url":"/java/2021/03/11/solid-principles.html","author":{"@type":"Person","name":"Duc Nguyen"},"headline":"SOLID Principles","dateModified":"2021-03-11T00:00:00+07:00","datePublished":"2021-03-11T00:00:00+07:00","description":"The SOLID Principles are five principles of Object-Oriented class design. They are a set of rules and best practices to follow while designing a class structure. These five principles help us understand the need for certain design patterns and software architecture in general. Following the SOLID acronym, they are: THE SINGLE RESPONSIBILITY PRINCIPLE THE OPEN-CLOSED PRINCIPLE LISKOV SUBSTITUTION PRINCIPLE INTERFACE SEGREGATION PRINCIPLE DEPENDENCY INVERSION PRINCIPLE More information THE SINGLE RESPONSIBILITY PRINCIPLE The Single Responsibility Principle states that a class should do one thing and therefore it should have only a single reason to change. Example: Let’s consider a class that contains code that changes the text in some way. The only job of this class should be manipulating text. Although this may seem fine, it is not a good example of the SRP. Here we have two responsibilities: manipulating and printing the text. public class TextManipulator { private String text; public TextManipulator(String text) { this.text = text; } public String getText() { return text; } public void appendText(String newText) { text = text.concat(newText); } public String findWordAndReplace(String word, String replacementWord) { if (text.contains(word)) { text = text.replace(word, replacementWord); } return text; } public String findWordAndDelete(String word) { if (text.contains(word)) { text = text.replace(word, &quot;&quot;); } return text; } public void printText() { System.out.println(textManipulator.getText()); } } Having a method that prints out text in this class violate the Single Responsibility Principle. For this purpose, we should create another class, which will only handle printing text: public class TextPrinter { TextManipulator textManipulator; public TextPrinter(TextManipulator textManipulator) { this.textManipulator = textManipulator; } public void printText() { System.out.println(textManipulator.getText()); } public void printOutEachWordOfText() { System.out.println(Arrays.toString(textManipulator.getText() .split(&quot; &quot;))); } public void printRangeOfCharacters(int startingIndex, int endIndex) { System.out.println(textManipulator.getText().substring(startingIndex, endIndex)); } } Let’s go back to our TextManipulator class methods: public class TextManipulator { private String text; public TextManipulator(String text) { this.text = text; } public String getText() { return text; } public void appendText(String newText) { text = text.concat(newText); } public String findWordAndReplace(String word, String replacementWord) { if (text.contains(word)) { text = text.replace(word, replacementWord); } return text; } public String findWordAndDelete(String word) { if (text.contains(word)) { text = text.replace(word, &quot;&quot;); } return text; } } THE OPEN-CLOSED PRINCIPLE The Open-Closed Principle requires that classes should be open for extension and closed to modification. Modification means changing the code of an existing class, and extension means adding new functionality. Example with non open-closed principle public class HealthInsuranceSurveyor{ public boolean isValidClaim(){ System.out.println(&quot;HealthInsuranceSurveyor: Validating health insurance claim...&quot;); /*Logic to validate health insurance claims*/ return true; } } public class ClaimApprovalManager { public void processHealthClaim (HealthInsuranceSurveyor surveyor) { if(surveyor.isValidClaim()){ System.out.println(&quot;ClaimApprovalManager: Valid claim. Currently processing claim for approval....&quot;); } } } /** Both the HealthInsuranceSurveyor and ClaimApprovalManager classes work fine and the design for the insurance system appears perfect until a new requirement to process vehicle insurance claims arises. We now need to include a new VehicleInsuranceSurveyor class, and this should not create any problems. But, what we also need is to modify the ClaimApprovalManager class to process vehicle insurance claims. This is how the modified ClaimApprovalManager will be: **/ public class ClaimApprovalManager { public void processHealthClaim (HealthInsuranceSurveyor surveyor) { if(surveyor.isValidClaim()){ System.out.println(&quot;ClaimApprovalManager: Valid claim. Currently processing claim for approval....&quot;); } } public void processVehicleClaim (VehicleInsuranceSurveyor surveyor) { if(surveyor.isValidClaim()){ System.out.println(&quot;ClaimApprovalManager: Valid claim. Currently processing claim for approval....&quot;); } } } Example with applying open-closed principle public abstract class InsuranceSurveyor { public abstract boolean isValidClaim(); } public class HealthInsuranceSurveyor extends InsuranceSurveyor{ public boolean isValidClaim(){ System.out.println(&quot;HealthInsuranceSurveyor: Validating health insurance claim...&quot;); /*Logic to validate health insurance claims*/ return true; } } public class VehicleInsuranceSurveyor extends InsuranceSurveyor{ public boolean isValidClaim(){ System.out.println(&quot;VehicleInsuranceSurveyor: Validating vehicle insurance claim...&quot;); /*Logic to validate vehicle insurance claims*/ return true; } } public class ClaimApprovalManager { public void processClaim(InsuranceSurveyor surveyor) { if(surveyor.isValidClaim()){ System.out.println(&quot;ClaimApprovalManager: Valid claim. Currently processing claim for approval....&quot;); } } } public class ClaimApprovalManagerTest { @Test public void testProcessClaim() throws Exception { HealthInsuranceSurveyor healthInsuranceSurveyor=new HealthInsuranceSurveyor(); ClaimApprovalManager claim1=new ClaimApprovalManager(); claim1.processClaim(healthInsuranceSurveyor); VehicleInsuranceSurveyor vehicleInsuranceSurveyor=new VehicleInsuranceSurveyor(); ClaimApprovalManager claim2=new ClaimApprovalManager(); claim2.processClaim(vehicleInsuranceSurveyor); } } LISKOV SUBSTITUTION PRINCIPLE The Liskov Substitution Principle states that subclasses should be substitutable for their base classes. INTERFACE SEGREGATION PRINCIPLE Segregation means keeping things separated, and the Interface Segregation Principle is about separating the interfaces. The principle states that many client-specific interfaces are better than one general-purpose interface. Clients should not be forced to implement a function they do no need. DEPENDENCY INVERSION PRINCIPLE The Dependency Inversion principle states that our classes should depend upon interfaces or abstract classes instead of concrete classes and functions.","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="KaizenThink" /><!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-NZ8G5007GK"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-NZ8G5007GK');
</script></head><body>
  <div class="container-flush">
    <div class="row"><!-- navigation bar -->
<div class="col-lg-12">
  <nav class="navbar navbar-expand-lg navbar-dark bg-dark" role="banner"><a class="navbar-brand site-title" rel="author" href="/">KaizenThink</a>

    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav"
      aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="navbarNav">
      <ul class="nav navbar-nav"><li class="nav-item active">
          <a class="nav-link" href="/about">About</a>
        </li><li class="nav-item active">
          <a class="nav-link" href="/">Java</a>
        </li><li class="nav-item active">
          <a class="nav-link" href="/docker">Docker</a>
        </li><li class="nav-item active">
          <a class="nav-link" href="/database">Database</a>
        </li><li class="nav-item active">
          <a class="nav-link" href="/data-science">Data-Science</a>
        </li><li class="nav-item active">
          <a class="nav-link" href="/ci-cd">CI-CD</a>
        </li><li class="nav-item active">
          <a class="nav-link" href="/python">Python</a>
        </li><li class="nav-item active">
          <a class="nav-link" href="/fe">FE</a>
        </li><li class="nav-item active">
          <a class="nav-link" href="/others">Others</a>
        </li></ul>
    </div>

    <!-- Html Elements for Search -->
    <div id="search-container" class="btn-group">
      <input type="text" id="search-input" placeholder="search...">
      <button id="clear">clear</button>
      <ul id="results-container"></ul>
    </div>

    <!-- Script pointing to search-script.js -->
    <script src="/java-scripts/search-script.js" type="text/javascript"></script>

    <!-- Configuration -->
    <script>
      SimpleJekyllSearch({
        searchInput: document.getElementById('search-input'),
        resultsContainer: document.getElementById('results-container'),
        json: '/search.json'
      })
    </script>

    <!-- search clear -->
    <script>
      window.addEventListener('load', () => {
        const button = document.querySelector('#clear');
        button.addEventListener('click', () => {
          document.querySelector('#search-input').value = "";
          document.querySelector('#results-container').innerHTML = "";
        });
      });
    </script>
  </nav>
</div></div>
  </div>

  <div class="container">
    <div class="row">
      <div class="col-lg-8 mx-auto">
  <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
    <header class="post-header">
      <h1 class="post-title p-name" itemprop="name headline">SOLID Principles</h1>
      <p class="post-meta">
        <time class="dt-published" datetime="2021-03-11T00:00:00+07:00" itemprop="datePublished">Mar 11, 2021
        </time></p>
    </header>
  
    <div class="post-content e-content" itemprop="articleBody">
      <blockquote>
  <p>The SOLID Principles are five principles of Object-Oriented class design. They are a set of rules and best practices to follow while designing a class structure.</p>
</blockquote>

<blockquote>
  <p>These five principles help us understand the need for certain design patterns and software architecture in general.</p>
</blockquote>

<blockquote>
  <p>Following the SOLID acronym, they are:</p>
</blockquote>

<ul id="markdown-toc">
  <li><a href="#the-single-responsibility-principle" id="markdown-toc-the-single-responsibility-principle">THE SINGLE RESPONSIBILITY PRINCIPLE</a></li>
  <li><a href="#the-open-closed-principle" id="markdown-toc-the-open-closed-principle">THE OPEN-CLOSED PRINCIPLE</a></li>
  <li><a href="#liskov-substitution-principle" id="markdown-toc-liskov-substitution-principle">LISKOV SUBSTITUTION PRINCIPLE</a></li>
  <li><a href="#interface-segregation-principle" id="markdown-toc-interface-segregation-principle">INTERFACE SEGREGATION PRINCIPLE</a></li>
  <li><a href="#dependency-inversion-principle" id="markdown-toc-dependency-inversion-principle">DEPENDENCY INVERSION PRINCIPLE</a></li>
</ul>

<p><a href="https://www.freecodecamp.org/news/solid-principles-explained-in-plain-english/">More information</a></p>

<h2 id="the-single-responsibility-principle">THE SINGLE RESPONSIBILITY PRINCIPLE</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">The Single Responsibility Principle</code> states that a class should do <strong>one thing</strong> and therefore it should have <strong>only a single reason to change</strong>.</li>
  <li><a href="https://www.baeldung.com/java-single-responsibility-principle#:~:text=As%20the%20name%20suggests%2C%20this,only%20one%20reason%20to%20change.">Example:</a>
    <ul>
      <li>Let’s consider a class that contains code that changes the text in some way. The only job of this class should be <strong>manipulating text</strong>. Although this may seem fine, it is not a good example of the SRP. Here we have <strong>two responsibilities: manipulating and printing the text.</strong></li>
    </ul>
  </li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TextManipulator</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">text</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">TextManipulator</span><span class="o">(</span><span class="nc">String</span> <span class="n">text</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">text</span> <span class="o">=</span> <span class="n">text</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getText</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">text</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">appendText</span><span class="o">(</span><span class="nc">String</span> <span class="n">newText</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">text</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="na">concat</span><span class="o">(</span><span class="n">newText</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">findWordAndReplace</span><span class="o">(</span><span class="nc">String</span> <span class="n">word</span><span class="o">,</span> <span class="nc">String</span> <span class="n">replacementWord</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">text</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">word</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">text</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="na">replace</span><span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="n">replacementWord</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">text</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">findWordAndDelete</span><span class="o">(</span><span class="nc">String</span> <span class="n">word</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">text</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">word</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">text</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="na">replace</span><span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="s">""</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">text</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">printText</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">textManipulator</span><span class="o">.</span><span class="na">getText</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>Having a method that prints out text in this class violate the Single Responsibility Principle. For this purpose, we should create another class, which will only handle printing text:</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TextPrinter</span> <span class="o">{</span>
    <span class="nc">TextManipulator</span> <span class="n">textManipulator</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">TextPrinter</span><span class="o">(</span><span class="nc">TextManipulator</span> <span class="n">textManipulator</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">textManipulator</span> <span class="o">=</span> <span class="n">textManipulator</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">printText</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">textManipulator</span><span class="o">.</span><span class="na">getText</span><span class="o">());</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">printOutEachWordOfText</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">textManipulator</span><span class="o">.</span><span class="na">getText</span><span class="o">()</span>
        <span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">" "</span><span class="o">)));</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">printRangeOfCharacters</span><span class="o">(</span><span class="kt">int</span> <span class="n">startingIndex</span><span class="o">,</span> <span class="kt">int</span> <span class="n">endIndex</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">textManipulator</span><span class="o">.</span><span class="na">getText</span><span class="o">().</span><span class="na">substring</span><span class="o">(</span><span class="n">startingIndex</span><span class="o">,</span> <span class="n">endIndex</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>Let’s go back to our TextManipulator class methods:
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TextManipulator</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="nc">String</span> <span class="n">text</span><span class="o">;</span>

  <span class="kd">public</span> <span class="nf">TextManipulator</span><span class="o">(</span><span class="nc">String</span> <span class="n">text</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">this</span><span class="o">.</span><span class="na">text</span> <span class="o">=</span> <span class="n">text</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getText</span><span class="o">()</span> <span class="o">{</span>
      <span class="k">return</span> <span class="n">text</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">appendText</span><span class="o">(</span><span class="nc">String</span> <span class="n">newText</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">text</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="na">concat</span><span class="o">(</span><span class="n">newText</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="nc">String</span> <span class="nf">findWordAndReplace</span><span class="o">(</span><span class="nc">String</span> <span class="n">word</span><span class="o">,</span> <span class="nc">String</span> <span class="n">replacementWord</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">text</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">word</span><span class="o">))</span> <span class="o">{</span>
          <span class="n">text</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="na">replace</span><span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="n">replacementWord</span><span class="o">);</span>
      <span class="o">}</span>
      <span class="k">return</span> <span class="n">text</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="nc">String</span> <span class="nf">findWordAndDelete</span><span class="o">(</span><span class="nc">String</span> <span class="n">word</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">text</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">word</span><span class="o">))</span> <span class="o">{</span>
          <span class="n">text</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="na">replace</span><span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="s">""</span><span class="o">);</span>
      <span class="o">}</span>
      <span class="k">return</span> <span class="n">text</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="the-open-closed-principle">THE OPEN-CLOSED PRINCIPLE</h2>
<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">The Open-Closed Principle</code> requires that classes <strong>should be open for extension</strong> and <strong>closed to modification</strong>.</p>
  </li>
  <li>
    <p><strong>Modification</strong> means changing the code of an existing class, and <strong>extension</strong> means adding new functionality.</p>
  </li>
  <li>
    <p>Example with non <strong>open-closed principle</strong></p>
  </li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">public</span> <span class="kd">class</span> <span class="nc">HealthInsuranceSurveyor</span><span class="o">{</span>
        <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isValidClaim</span><span class="o">(){</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"HealthInsuranceSurveyor: Validating health insurance claim..."</span><span class="o">);</span>
            <span class="cm">/*Logic to validate health insurance claims*/</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">class</span> <span class="nc">ClaimApprovalManager</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">processHealthClaim</span> <span class="o">(</span><span class="nc">HealthInsuranceSurveyor</span> <span class="n">surveyor</span><span class="o">)</span>
        <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">surveyor</span><span class="o">.</span><span class="na">isValidClaim</span><span class="o">()){</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"ClaimApprovalManager: Valid claim. Currently processing claim for approval...."</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/** Both the HealthInsuranceSurveyor and ClaimApprovalManager classes work fine
     and the design for the insurance system appears perfect until a new requirement
      to process vehicle insurance claims arises.
        We now need to include a new VehicleInsuranceSurveyor class, and this should not create any problems.
        But, what we also need is to modify the ClaimApprovalManager class to process vehicle insurance claims.
        This is how the modified ClaimApprovalManager will be:
    **/</span>

    <span class="kd">public</span> <span class="kd">class</span> <span class="nc">ClaimApprovalManager</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">processHealthClaim</span> <span class="o">(</span><span class="nc">HealthInsuranceSurveyor</span> <span class="n">surveyor</span><span class="o">)</span>
        <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">surveyor</span><span class="o">.</span><span class="na">isValidClaim</span><span class="o">()){</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"ClaimApprovalManager: Valid claim. Currently processing claim for approval...."</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">processVehicleClaim</span> <span class="o">(</span><span class="nc">VehicleInsuranceSurveyor</span> <span class="n">surveyor</span><span class="o">)</span>
        <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">surveyor</span><span class="o">.</span><span class="na">isValidClaim</span><span class="o">()){</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"ClaimApprovalManager: Valid claim. Currently processing claim for approval...."</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<ul>
  <li>Example with applying open-closed principle</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">InsuranceSurveyor</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">boolean</span> <span class="nf">isValidClaim</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">class</span> <span class="nc">HealthInsuranceSurveyor</span> <span class="kd">extends</span> <span class="nc">InsuranceSurveyor</span><span class="o">{</span>
        <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isValidClaim</span><span class="o">(){</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"HealthInsuranceSurveyor: Validating health insurance claim..."</span><span class="o">);</span>
            <span class="cm">/*Logic to validate health insurance claims*/</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">class</span> <span class="nc">VehicleInsuranceSurveyor</span> <span class="kd">extends</span> <span class="nc">InsuranceSurveyor</span><span class="o">{</span>
        <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isValidClaim</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"VehicleInsuranceSurveyor: Validating vehicle insurance claim..."</span><span class="o">);</span>
            <span class="cm">/*Logic to validate vehicle insurance claims*/</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">class</span> <span class="nc">ClaimApprovalManager</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">processClaim</span><span class="o">(</span><span class="nc">InsuranceSurveyor</span> <span class="n">surveyor</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">surveyor</span><span class="o">.</span><span class="na">isValidClaim</span><span class="o">()){</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"ClaimApprovalManager: Valid claim. Currently processing claim for approval...."</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">class</span> <span class="nc">ClaimApprovalManagerTest</span> <span class="o">{</span>
        <span class="nd">@Test</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">testProcessClaim</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">HealthInsuranceSurveyor</span> <span class="n">healthInsuranceSurveyor</span><span class="o">=</span><span class="k">new</span> <span class="nc">HealthInsuranceSurveyor</span><span class="o">();</span>
        <span class="nc">ClaimApprovalManager</span> <span class="n">claim1</span><span class="o">=</span><span class="k">new</span> <span class="nc">ClaimApprovalManager</span><span class="o">();</span>
        <span class="n">claim1</span><span class="o">.</span><span class="na">processClaim</span><span class="o">(</span><span class="n">healthInsuranceSurveyor</span><span class="o">);</span>
            <span class="nc">VehicleInsuranceSurveyor</span> <span class="n">vehicleInsuranceSurveyor</span><span class="o">=</span><span class="k">new</span> <span class="nc">VehicleInsuranceSurveyor</span><span class="o">();</span>
            <span class="nc">ClaimApprovalManager</span> <span class="n">claim2</span><span class="o">=</span><span class="k">new</span> <span class="nc">ClaimApprovalManager</span><span class="o">();</span>
            <span class="n">claim2</span><span class="o">.</span><span class="na">processClaim</span><span class="o">(</span><span class="n">vehicleInsuranceSurveyor</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

</code></pre></div></div>

<h2 id="liskov-substitution-principle">LISKOV SUBSTITUTION PRINCIPLE</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">The Liskov Substitution Principle</code> states that subclasses should be substitutable for their base classes.</li>
</ul>

<h2 id="interface-segregation-principle">INTERFACE SEGREGATION PRINCIPLE</h2>
<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Segregation</code> means <strong>keeping things separated</strong>, and the <code class="language-plaintext highlighter-rouge">Interface Segregation Principle</code> is about <strong>separating the interfaces</strong>.</p>
  </li>
  <li>
    <p>The principle states that <strong>many client-specific interfaces are better than one general-purpose interface</strong>. Clients should not be forced to implement a function they do no need.</p>
  </li>
</ul>

<h2 id="dependency-inversion-principle">DEPENDENCY INVERSION PRINCIPLE</h2>
<ul>
  <li>The Dependency Inversion principle states that our classes should depend upon interfaces or abstract classes instead of concrete classes and functions.</li>
</ul>

    </div><a class="u-url" href="/java/2021/03/11/solid-principles.html" hidden></a>
  </article>
  
</div>


    </div>
  </div>
  <script src="https://unpkg.com/vanilla-back-to-top@7.2.1/dist/vanilla-back-to-top.min.js"></script>
  <script>addBackToTop()</script>
</body>
<footer><footer class="site-footer h-card">
  <div class="container">
    <div class="row">
      <div class="col-md-4">
        <h2 class="footer-heading">KaizenThink</h2>
        <div>
          <div>
            <ul>
              <li>Duc Nguyen</li><li><a class="u-email" href="mailto:minhducnguyen189@gmail.com">minhducnguyen189@gmail.com</a></li><li>&copy; 2021 Duc Nguyen. Powered by <a href="https://jekyllrb.com/">Jekyll</a></li>
            </ul>
          </div>
        </div>
      </div>
      <div class="col-md-4">
        <data class="u-url" href="/%20/"></data>
        <div><ul class="social-media-list"><li><a href="https://github.com/minhducnguyen189"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">minhducnguyen189</span></a></li><li><a href="https://www.linkedin.com/in/duc-nguyen-03109b141"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#linkedin"></use></svg> <span class="username">duc-nguyen-03109b141</span></a></li></ul>
</div>
      </div>
      <div class="col-md-4">
        <h3>Support me</h3>
        <!-- PayPal Logo -->
        <table id="sponsor" border='0' cellpadding='10' cellspacing='0' align='center'>
          <tr>
            <td align='center'>
              <a href='https://www.paypal.com/paypalme/minhduc189' title='Sponsor me'
                onclick="javascript:window.open('https://www.paypal.com/paypalme/minhduc189','WIPaypal','toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=yes, resizable=yes, width=1060, height=700'); return false;">
                <img src='https://www.paypalobjects.com/webstatic/en_US/i/buttons/PP_logo_h_150x38.png' alt='PayPal Acceptance | Medium v2' />
              </a>
            </td>
          </tr>
        </table>
        <!-- PayPal Logo -->
      </div>
    </div>
  </div>
</footer>
</footer>
</html>