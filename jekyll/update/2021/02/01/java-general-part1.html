<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- bootstrap library and JS, Jquery -->
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css"
    integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
  <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js"
    integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo"
    crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js"
    integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1"
    crossorigin="anonymous"></script>
  <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"
    integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM"
    crossorigin="anonymous"></script><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>General Knowledges About Java Part 1 | StepByStep</title>
<meta name="generator" content="Jekyll v4.2.1" />
<meta property="og:title" content="General Knowledges About Java Part 1" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="HISTORY James Gosling, Mike Sheridan, and Patrick Naughton initiated the Java language project in June 1991. Java was originally designed for interactive television, but it was too advanced for the digital cable television industry at the time. The language was initially called Oak after an oak tree that stood outside Gosling’s office. Later the project went by the name Green and was finally renamed Java, from Java coffee. Gosling designed Java with a C/C++-style syntax that system and application programmers would find familiar. More details JAVA BASIC COLLECTION FARMEWORK java.util.collection is the root interface of Collection Framework. It constains some important methods such as size(), iterator(), add(), remove() and clear(). List, Set Queue are other important interfaces that inherit from the Collection interface. Map is the only interface that does not inherit from the Collection interface but it is part of Collection Framework. All the collection framework interfaces are present in java.util.package JAVA GENERIC Java Generics was added in Java 5 to provide complile time type checking and removing risk of ClassCastException which was common while working with collection classes. // Before Java 5 List list = new ArrayList(); // Java 5 and after List&lt;String&gt; list = new ArrayList&lt;String&gt;(); Generic Class: We can define our own classes with generic type. A generic type is a class or interface that is prameterized over types. We use bracket (&lt;&gt;) to specify the type parameter. public class GenericsType&lt;T&gt;() { private T t; public T get() { return this.t; } public void set(T t1) { this.t = t1 } } // Create Class Generic Type GenericsType&lt;String&gt; type = new GenericsType&lt;&gt;(); type.set(&quot;this is string&quot;); Generic Interface: // Create Interface with Generic Type public interface Application(T, S) { public T getApplication(S appId); } Java Generic Type: Java Generic Type naming convention helps us understanding code easily and having a naming convention is one of the best practices of Java programming language. The most commonly used type parameter names are: E - Element (used extensively by Java Collection Framework. Ex: ArrayList, Set, etc) K - Key (Used in Map) N - Number T - Type V - Value (Used in Map) S, U, V etc - 2nd, 3rdm 4th types Java Generic Method public static &lt;T&gt; T cloneObject(T t, Class&lt;T&gt; type) { try { ObjectMapper mapper = new ObjectMapper(); String objectString = mapper.writeValueAsString(t); return mapper.readValue(objectString, type); } catch (JsonProcessingException e) { Throw new RuntimeException(&quot;Clone object error!: &quot; + e.getMessage()); } } JAVA 8 OPTIONAL Optional is a container object which may or maynot contain a non-null value. There are various methods available in the API to deal with the Optional in a convenient and reliable maner. // Ex: Create an Optional Object contains non-null value String str = &quot;abc&quot;; Optional&lt;String&gt; opt = Optional.of(str); // Ex: Create an Optional Object contains value // or empty if the input parameter is null Optional&lt;String&gt; opt = Optional.ofNullable(str); Why use Optional.of over Optional.ofNullable ? //Ex: String foobar = &lt;value or null&gt; Optional.of(foobar); //May throw NullPointerException Optional.ofNullable(foobar); //Safe from NullPointerException Answer: If you expect that your foobar is never null due to the program logic, it’s much better to use Optional.of(foobar) as you will see a NullPointerException which will indicate that your program has a bug. If you use Optional.ofNullable(foobar) and the foobar happens to be null due to the bug, then your program will silently continue working incorectly, which maybe a bigger disaster. This way of error may occur much later and it would be much harder to understand at which point it went wrong. JAVA 8 INTERFACE WITH DEFAULT METHOD Default methods help us expand interface without broken classes that implemented. Deafult methods will help us in avoiding utility classes. Default methods will help us in removing base implementabtion classes, we can provide default implementation and the implementation classes can choose which one to ooverride. If there are any class that inherit a same default method, the this default method will not be valid. The same thing is that a default method can not override a method from java.lang.object bacause Object is the base class of all classes in java. So, If we have methods in Object class which are defined as default methods in interface, the methods in Object class will be always used. This is the reason why we do not have any default methos can override methods of Object class. // default method of interface example public interface FirstInterface { void firstMethod(Striing string); default void log(String string) { System.out.println(&quot;This is the default method: &quot; + string); } } As we know that, Java does not allow multi inheritances with class because the compiler does not know choose which method of super class to use. So, this happens the same for dafeult method bacause if you implement a class from 2 interface Ex: FirstInterface and SecondInterface, the compiler does not know choosing which one to execute. Multi ingeritances is a normal thing in java, we usually see this issue in java core classes, also most of enterprise and framwework application. To ensure this issue can not with interface, class has to implement common mothods default from 2 interface. So, as in the example below, class have to implement log() method for compiler can not throw exception. // default method of first interface example public interface FirstInterface { void firstMethod(Striing string); default void log(String string) { System.out.println(&quot;This is the default method: &quot; + string); } } // default method of second interface example public interface SecondInterface { void secondMethod(Striing string); default void log(String string) { System.out.println(&quot; default method: &quot; + string); } } public class MyClass impelemts FirstInterface, SecondInterface { @Override public void firstMethod() {} @Override public void secondMethod() {} @Override public void log(String string) { System.out.println(&quot;MyClass logging: &quot; + string); } } JAVA 8 INTERFACE WITH STATIC METHOD Java interface static method is similar to default method except that we can not override them in the implementation classes. This feature helps us in avoiding undesired results incase of poor implementation in implementation classes. public interface ThirdInterface { default void print(String str) { if(!isNull(str)) { System.out.println(&quot;ThirdInterface print: &quot; + str); } } static boolean isNull(String str) { System.out.println(&quot;Interface null check&quot;); return str == null ? true : &quot;&quot;.equal(str) ? true : false; } } public class ThridImpl implements ThirdInterface { public boolean isNull(String str) { System.out.println(&quot;Impl null check&quot;); return str == null ? true : false; } } //test public static void main(String args[]) { ThirdImpl obj = new ThirdImpl(); obj.print(&quot;&quot;); obj.isNull(&quot;abc&quot;); } Then we can see the results in the log as below: Interface null check Impl null check If we make the interface method from static to default, we will get following output: Impl null check ThirdInterface print: abc Impl null check Java interface static method is part of interface, we can not use it for implementation class objects. Java interface static methods are good for providing utility methods, for example null check, collection sorting etc. Java interface static method helps us in providing security by not allowing implementation classes to override them. We can not define static method in methods of object class, then we can get the error “this static method can not hide the instance method from Object”. This is no acceptable in java, when object is a base class for all classes, we can not have a static method and other method with the same format. We can use static methods to remove utility methods as Collections and make methods can connect to interface then we can easily find and use these methods." />
<meta property="og:description" content="HISTORY James Gosling, Mike Sheridan, and Patrick Naughton initiated the Java language project in June 1991. Java was originally designed for interactive television, but it was too advanced for the digital cable television industry at the time. The language was initially called Oak after an oak tree that stood outside Gosling’s office. Later the project went by the name Green and was finally renamed Java, from Java coffee. Gosling designed Java with a C/C++-style syntax that system and application programmers would find familiar. More details JAVA BASIC COLLECTION FARMEWORK java.util.collection is the root interface of Collection Framework. It constains some important methods such as size(), iterator(), add(), remove() and clear(). List, Set Queue are other important interfaces that inherit from the Collection interface. Map is the only interface that does not inherit from the Collection interface but it is part of Collection Framework. All the collection framework interfaces are present in java.util.package JAVA GENERIC Java Generics was added in Java 5 to provide complile time type checking and removing risk of ClassCastException which was common while working with collection classes. // Before Java 5 List list = new ArrayList(); // Java 5 and after List&lt;String&gt; list = new ArrayList&lt;String&gt;(); Generic Class: We can define our own classes with generic type. A generic type is a class or interface that is prameterized over types. We use bracket (&lt;&gt;) to specify the type parameter. public class GenericsType&lt;T&gt;() { private T t; public T get() { return this.t; } public void set(T t1) { this.t = t1 } } // Create Class Generic Type GenericsType&lt;String&gt; type = new GenericsType&lt;&gt;(); type.set(&quot;this is string&quot;); Generic Interface: // Create Interface with Generic Type public interface Application(T, S) { public T getApplication(S appId); } Java Generic Type: Java Generic Type naming convention helps us understanding code easily and having a naming convention is one of the best practices of Java programming language. The most commonly used type parameter names are: E - Element (used extensively by Java Collection Framework. Ex: ArrayList, Set, etc) K - Key (Used in Map) N - Number T - Type V - Value (Used in Map) S, U, V etc - 2nd, 3rdm 4th types Java Generic Method public static &lt;T&gt; T cloneObject(T t, Class&lt;T&gt; type) { try { ObjectMapper mapper = new ObjectMapper(); String objectString = mapper.writeValueAsString(t); return mapper.readValue(objectString, type); } catch (JsonProcessingException e) { Throw new RuntimeException(&quot;Clone object error!: &quot; + e.getMessage()); } } JAVA 8 OPTIONAL Optional is a container object which may or maynot contain a non-null value. There are various methods available in the API to deal with the Optional in a convenient and reliable maner. // Ex: Create an Optional Object contains non-null value String str = &quot;abc&quot;; Optional&lt;String&gt; opt = Optional.of(str); // Ex: Create an Optional Object contains value // or empty if the input parameter is null Optional&lt;String&gt; opt = Optional.ofNullable(str); Why use Optional.of over Optional.ofNullable ? //Ex: String foobar = &lt;value or null&gt; Optional.of(foobar); //May throw NullPointerException Optional.ofNullable(foobar); //Safe from NullPointerException Answer: If you expect that your foobar is never null due to the program logic, it’s much better to use Optional.of(foobar) as you will see a NullPointerException which will indicate that your program has a bug. If you use Optional.ofNullable(foobar) and the foobar happens to be null due to the bug, then your program will silently continue working incorectly, which maybe a bigger disaster. This way of error may occur much later and it would be much harder to understand at which point it went wrong. JAVA 8 INTERFACE WITH DEFAULT METHOD Default methods help us expand interface without broken classes that implemented. Deafult methods will help us in avoiding utility classes. Default methods will help us in removing base implementabtion classes, we can provide default implementation and the implementation classes can choose which one to ooverride. If there are any class that inherit a same default method, the this default method will not be valid. The same thing is that a default method can not override a method from java.lang.object bacause Object is the base class of all classes in java. So, If we have methods in Object class which are defined as default methods in interface, the methods in Object class will be always used. This is the reason why we do not have any default methos can override methods of Object class. // default method of interface example public interface FirstInterface { void firstMethod(Striing string); default void log(String string) { System.out.println(&quot;This is the default method: &quot; + string); } } As we know that, Java does not allow multi inheritances with class because the compiler does not know choose which method of super class to use. So, this happens the same for dafeult method bacause if you implement a class from 2 interface Ex: FirstInterface and SecondInterface, the compiler does not know choosing which one to execute. Multi ingeritances is a normal thing in java, we usually see this issue in java core classes, also most of enterprise and framwework application. To ensure this issue can not with interface, class has to implement common mothods default from 2 interface. So, as in the example below, class have to implement log() method for compiler can not throw exception. // default method of first interface example public interface FirstInterface { void firstMethod(Striing string); default void log(String string) { System.out.println(&quot;This is the default method: &quot; + string); } } // default method of second interface example public interface SecondInterface { void secondMethod(Striing string); default void log(String string) { System.out.println(&quot; default method: &quot; + string); } } public class MyClass impelemts FirstInterface, SecondInterface { @Override public void firstMethod() {} @Override public void secondMethod() {} @Override public void log(String string) { System.out.println(&quot;MyClass logging: &quot; + string); } } JAVA 8 INTERFACE WITH STATIC METHOD Java interface static method is similar to default method except that we can not override them in the implementation classes. This feature helps us in avoiding undesired results incase of poor implementation in implementation classes. public interface ThirdInterface { default void print(String str) { if(!isNull(str)) { System.out.println(&quot;ThirdInterface print: &quot; + str); } } static boolean isNull(String str) { System.out.println(&quot;Interface null check&quot;); return str == null ? true : &quot;&quot;.equal(str) ? true : false; } } public class ThridImpl implements ThirdInterface { public boolean isNull(String str) { System.out.println(&quot;Impl null check&quot;); return str == null ? true : false; } } //test public static void main(String args[]) { ThirdImpl obj = new ThirdImpl(); obj.print(&quot;&quot;); obj.isNull(&quot;abc&quot;); } Then we can see the results in the log as below: Interface null check Impl null check If we make the interface method from static to default, we will get following output: Impl null check ThirdInterface print: abc Impl null check Java interface static method is part of interface, we can not use it for implementation class objects. Java interface static methods are good for providing utility methods, for example null check, collection sorting etc. Java interface static method helps us in providing security by not allowing implementation classes to override them. We can not define static method in methods of object class, then we can get the error “this static method can not hide the instance method from Object”. This is no acceptable in java, when object is a base class for all classes, we can not have a static method and other method with the same format. We can use static methods to remove utility methods as Collections and make methods can connect to interface then we can easily find and use these methods." />
<link rel="canonical" href="/jekyll/update/2021/02/01/java-general-part1.html" />
<meta property="og:url" content="/jekyll/update/2021/02/01/java-general-part1.html" />
<meta property="og:site_name" content="StepByStep" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-02-01T20:15:47+07:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="General Knowledges About Java Part 1" />
<script type="application/ld+json">
{"@type":"BlogPosting","url":"/jekyll/update/2021/02/01/java-general-part1.html","dateModified":"2021-02-01T20:15:47+07:00","datePublished":"2021-02-01T20:15:47+07:00","headline":"General Knowledges About Java Part 1","mainEntityOfPage":{"@type":"WebPage","@id":"/jekyll/update/2021/02/01/java-general-part1.html"},"description":"HISTORY James Gosling, Mike Sheridan, and Patrick Naughton initiated the Java language project in June 1991. Java was originally designed for interactive television, but it was too advanced for the digital cable television industry at the time. The language was initially called Oak after an oak tree that stood outside Gosling’s office. Later the project went by the name Green and was finally renamed Java, from Java coffee. Gosling designed Java with a C/C++-style syntax that system and application programmers would find familiar. More details JAVA BASIC COLLECTION FARMEWORK java.util.collection is the root interface of Collection Framework. It constains some important methods such as size(), iterator(), add(), remove() and clear(). List, Set Queue are other important interfaces that inherit from the Collection interface. Map is the only interface that does not inherit from the Collection interface but it is part of Collection Framework. All the collection framework interfaces are present in java.util.package JAVA GENERIC Java Generics was added in Java 5 to provide complile time type checking and removing risk of ClassCastException which was common while working with collection classes. // Before Java 5 List list = new ArrayList(); // Java 5 and after List&lt;String&gt; list = new ArrayList&lt;String&gt;(); Generic Class: We can define our own classes with generic type. A generic type is a class or interface that is prameterized over types. We use bracket (&lt;&gt;) to specify the type parameter. public class GenericsType&lt;T&gt;() { private T t; public T get() { return this.t; } public void set(T t1) { this.t = t1 } } // Create Class Generic Type GenericsType&lt;String&gt; type = new GenericsType&lt;&gt;(); type.set(&quot;this is string&quot;); Generic Interface: // Create Interface with Generic Type public interface Application(T, S) { public T getApplication(S appId); } Java Generic Type: Java Generic Type naming convention helps us understanding code easily and having a naming convention is one of the best practices of Java programming language. The most commonly used type parameter names are: E - Element (used extensively by Java Collection Framework. Ex: ArrayList, Set, etc) K - Key (Used in Map) N - Number T - Type V - Value (Used in Map) S, U, V etc - 2nd, 3rdm 4th types Java Generic Method public static &lt;T&gt; T cloneObject(T t, Class&lt;T&gt; type) { try { ObjectMapper mapper = new ObjectMapper(); String objectString = mapper.writeValueAsString(t); return mapper.readValue(objectString, type); } catch (JsonProcessingException e) { Throw new RuntimeException(&quot;Clone object error!: &quot; + e.getMessage()); } } JAVA 8 OPTIONAL Optional is a container object which may or maynot contain a non-null value. There are various methods available in the API to deal with the Optional in a convenient and reliable maner. // Ex: Create an Optional Object contains non-null value String str = &quot;abc&quot;; Optional&lt;String&gt; opt = Optional.of(str); // Ex: Create an Optional Object contains value // or empty if the input parameter is null Optional&lt;String&gt; opt = Optional.ofNullable(str); Why use Optional.of over Optional.ofNullable ? //Ex: String foobar = &lt;value or null&gt; Optional.of(foobar); //May throw NullPointerException Optional.ofNullable(foobar); //Safe from NullPointerException Answer: If you expect that your foobar is never null due to the program logic, it’s much better to use Optional.of(foobar) as you will see a NullPointerException which will indicate that your program has a bug. If you use Optional.ofNullable(foobar) and the foobar happens to be null due to the bug, then your program will silently continue working incorectly, which maybe a bigger disaster. This way of error may occur much later and it would be much harder to understand at which point it went wrong. JAVA 8 INTERFACE WITH DEFAULT METHOD Default methods help us expand interface without broken classes that implemented. Deafult methods will help us in avoiding utility classes. Default methods will help us in removing base implementabtion classes, we can provide default implementation and the implementation classes can choose which one to ooverride. If there are any class that inherit a same default method, the this default method will not be valid. The same thing is that a default method can not override a method from java.lang.object bacause Object is the base class of all classes in java. So, If we have methods in Object class which are defined as default methods in interface, the methods in Object class will be always used. This is the reason why we do not have any default methos can override methods of Object class. // default method of interface example public interface FirstInterface { void firstMethod(Striing string); default void log(String string) { System.out.println(&quot;This is the default method: &quot; + string); } } As we know that, Java does not allow multi inheritances with class because the compiler does not know choose which method of super class to use. So, this happens the same for dafeult method bacause if you implement a class from 2 interface Ex: FirstInterface and SecondInterface, the compiler does not know choosing which one to execute. Multi ingeritances is a normal thing in java, we usually see this issue in java core classes, also most of enterprise and framwework application. To ensure this issue can not with interface, class has to implement common mothods default from 2 interface. So, as in the example below, class have to implement log() method for compiler can not throw exception. // default method of first interface example public interface FirstInterface { void firstMethod(Striing string); default void log(String string) { System.out.println(&quot;This is the default method: &quot; + string); } } // default method of second interface example public interface SecondInterface { void secondMethod(Striing string); default void log(String string) { System.out.println(&quot; default method: &quot; + string); } } public class MyClass impelemts FirstInterface, SecondInterface { @Override public void firstMethod() {} @Override public void secondMethod() {} @Override public void log(String string) { System.out.println(&quot;MyClass logging: &quot; + string); } } JAVA 8 INTERFACE WITH STATIC METHOD Java interface static method is similar to default method except that we can not override them in the implementation classes. This feature helps us in avoiding undesired results incase of poor implementation in implementation classes. public interface ThirdInterface { default void print(String str) { if(!isNull(str)) { System.out.println(&quot;ThirdInterface print: &quot; + str); } } static boolean isNull(String str) { System.out.println(&quot;Interface null check&quot;); return str == null ? true : &quot;&quot;.equal(str) ? true : false; } } public class ThridImpl implements ThirdInterface { public boolean isNull(String str) { System.out.println(&quot;Impl null check&quot;); return str == null ? true : false; } } //test public static void main(String args[]) { ThirdImpl obj = new ThirdImpl(); obj.print(&quot;&quot;); obj.isNull(&quot;abc&quot;); } Then we can see the results in the log as below: Interface null check Impl null check If we make the interface method from static to default, we will get following output: Impl null check ThirdInterface print: abc Impl null check Java interface static method is part of interface, we can not use it for implementation class objects. Java interface static methods are good for providing utility methods, for example null check, collection sorting etc. Java interface static method helps us in providing security by not allowing implementation classes to override them. We can not define static method in methods of object class, then we can get the error “this static method can not hide the instance method from Object”. This is no acceptable in java, when object is a base class for all classes, we can not have a static method and other method with the same format. We can use static methods to remove utility methods as Collections and make methods can connect to interface then we can easily find and use these methods.","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="StepByStep" /><!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-NZ8G5007GK"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-NZ8G5007GK');
</script></head><body>
  <div class="container-flush">
    <div class="row"><!-- navigation bar -->
<div class="col-lg-12">
  <nav class="navbar navbar-expand-lg navbar-dark bg-dark" role="banner"><a class="navbar-brand site-title" rel="author" href="/">StepByStep</a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav"
      aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="navbarNav">
      <ul class="nav navbar-nav"><li class="nav-item active">
          <a class="nav-link" href="/about/">About</a>
        </li><li class="nav-item active">
          <a class="nav-link" href="/ci-cd/">CI-CD</a>
        </li><li class="nav-item active">
          <a class="nav-link" href="/database/">Database</a>
        </li><li class="nav-item active">
          <a class="nav-link" href="/docker/">Docker</a>
        </li><li class="nav-item active">
          <a class="nav-link" href="/">Java</a>
        </li><li class="nav-item active">
          <a class="nav-link" href="/python/">Python</a>
        </li></ul>
    </div><!-- Html Elements for Search -->
    <div id="search-container" class="btn-group">
      <input type="text" id="search-input" placeholder="search...">
      <button id="clear">clear</button>
      <ul id="results-container"></ul>
    </div>

    <!-- Script pointing to search-script.js -->
    <script src="/java-scripts/search-script.js" type="text/javascript"></script>

    <!-- Configuration -->
    <script>
      SimpleJekyllSearch({
        searchInput: document.getElementById('search-input'),
        resultsContainer: document.getElementById('results-container'),
        json: '/search.json'
      })
    </script>

    <!-- search clear -->
    <script>
      window.addEventListener('load', () => {
          const button = document.querySelector('#clear');
          button.addEventListener('click', () => {
              document.querySelector('#search-input').value = "";
              document.querySelector('#results-container').innerHTML = "";
          });
      }); 
  </script>
  </nav>
</div></div>
  </div>

  <div class="container">
    <div class="row">
      <div class="col-lg-8 mx-auto">
  <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
    <header class="post-header">
      <h1 class="post-title p-name" itemprop="name headline">General Knowledges About Java Part 1</h1>
      <p class="post-meta">
        <time class="dt-published" datetime="2021-02-01T20:15:47+07:00" itemprop="datePublished">Feb 1, 2021
        </time></p>
    </header>
  
    <div class="post-content e-content" itemprop="articleBody">
      <h2 id="history">HISTORY</h2>

<ul>
  <li>
    <p><strong>James Gosling, Mike Sheridan, and Patrick Naughton</strong> initiated the Java language project in June 1991. Java was originally designed for interactive television, but it was too advanced for the digital cable television industry at the time. The language was initially called Oak after an oak tree that stood outside Gosling’s office. Later the project went by the name Green and was finally renamed Java, from Java coffee. Gosling designed Java with a C/C++-style syntax that system and application programmers would find familiar.</p>
  </li>
  <li>
    <p><a href="https://www.tutorialspoint.com/java/">More details</a></p>
  </li>
</ul>

<h2 id="java-basic">JAVA BASIC</h2>

<blockquote>
  <h3 id="collection-farmework-">COLLECTION FARMEWORK <br /></h3>
</blockquote>

<ul>
  <li>
    <p><strong>java.util.collection</strong> is the root interface of Collection Framework. It constains some important methods such as <strong>size(), iterator(), add(), remove() and clear()</strong>.</p>
  </li>
  <li>
    <p><strong>List, Set Queue</strong> are other important interfaces that inherit from the Collection interface.</p>
  </li>
  <li>
    <p><strong>Map</strong> is the only interface that does not inherit from the Collection interface but it is part of Collection Framework.</p>
  </li>
  <li>
    <p>All the collection framework interfaces are present in <strong>java.util.package</strong></p>
  </li>
</ul>

<blockquote>
  <h3 id="java-generic-">JAVA GENERIC <br /></h3>
</blockquote>

<ul>
  <li>Java Generics was added in Java 5 to provide complile time type checking and removing risk of <strong>ClassCastException</strong> which was common while working with collection classes.</li>
</ul>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">// Before Java 5</span>

    <span class="nc">List</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">();</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">// Java 5 and after</span>
    
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;();</span>
</code></pre></div></div>
<ul>
  <li><strong>Generic Class:</strong> <br /> 
We can define our own classes with generic type. A generic type is a class or interface that is prameterized over types. We use bracket <strong>(&lt;&gt;)</strong> to specify the type parameter.</li>
</ul>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">GenericsType</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;()</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">t</span><span class="o">;</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">t</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="no">T</span> <span class="n">t1</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">t</span> <span class="o">=</span> <span class="n">t1</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<hr />
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">// Create Class Generic Type</span>

    <span class="nc">GenericsType</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">type</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">GenericsType</span><span class="o">&lt;&gt;();</span>
    <span class="n">type</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="s">"this is string"</span><span class="o">);</span>
</code></pre></div></div>

<ul>
  <li><strong>Generic Interface:</strong> <br /></li>
</ul>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Create Interface with Generic Type</span>

<span class="kd">public</span> <span class="kd">interface</span> <span class="nf">Application</span><span class="o">(</span><span class="no">T</span><span class="o">,</span> <span class="no">S</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getApplication</span><span class="o">(</span><span class="no">S</span> <span class="n">appId</span><span class="o">);</span>
<span class="o">}</span>

</code></pre></div></div>
<ul>
  <li>Java Generic Type: <br />
Java Generic Type naming convention helps us understanding code easily and having a naming convention is one of the best practices of Java programming language. The most commonly used type parameter names are: <br /></li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>E - Element (used extensively by Java Collection Framework. Ex: ArrayList, Set, etc)
K - Key (Used in Map)
N - Number
T - Type
V - Value (Used in Map)
S, U, V etc - 2nd, 3rdm 4th types
</code></pre></div></div>
<p><br /></p>
<ul>
  <li>Java Generic Method <br /></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="no">T</span> <span class="nf">cloneObject</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">,</span> <span class="nc">Class</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">type</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="nc">ObjectMapper</span> <span class="n">mapper</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ObjectMapper</span><span class="o">();</span>
        <span class="nc">String</span> <span class="n">objectString</span> <span class="o">=</span> <span class="n">mapper</span><span class="o">.</span><span class="na">writeValueAsString</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">mapper</span><span class="o">.</span><span class="na">readValue</span><span class="o">(</span><span class="n">objectString</span><span class="o">,</span> <span class="n">type</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">JsonProcessingException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"Clone object error!: "</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<blockquote>
  <h3 id="java-8-optional-">JAVA 8 OPTIONAL <br /></h3>
</blockquote>

<ul>
  <li><strong>Optional</strong> is a container object which may or maynot contain a non-null value. There are various methods available in the API to deal with the Optional in a convenient and reliable maner. 
<br /></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Ex: Create an Optional Object contains non-null value</span>
<span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"abc"</span><span class="o">;</span>
<span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">opt</span> <span class="o">=</span> <span class="nc">Optional</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">str</span><span class="o">);</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Ex: Create an Optional Object contains value </span>
<span class="c1">// or empty if the input parameter is null</span>
<span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">opt</span> <span class="o">=</span> <span class="nc">Optional</span><span class="o">.</span><span class="na">ofNullable</span><span class="o">(</span><span class="n">str</span><span class="o">);</span>
</code></pre></div></div>
<ul>
  <li>Why use <code class="language-plaintext highlighter-rouge">Optional.of</code> over <code class="language-plaintext highlighter-rouge">Optional.ofNullable</code> ?</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1">//Ex:</span>
 <span class="nc">String</span> <span class="n">foobar</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">value</span> <span class="n">or</span> <span class="kc">null</span><span class="o">&gt;</span>
 <span class="nc">Optional</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">foobar</span><span class="o">);</span> <span class="c1">//May throw NullPointerException</span>
 <span class="nc">Optional</span><span class="o">.</span><span class="na">ofNullable</span><span class="o">(</span><span class="n">foobar</span><span class="o">);</span> <span class="c1">//Safe from NullPointerException</span>
</code></pre></div></div>
<ul>
  <li>Answer: If you expect that your <strong>foobar</strong> is <strong>never null</strong> due to the program logic, it’s much better to use <code class="language-plaintext highlighter-rouge">Optional.of(foobar)</code> as you will see a <strong>NullPointerException</strong> which will indicate that your program has a bug. If you use <code class="language-plaintext highlighter-rouge">Optional.ofNullable(foobar)</code> and the <strong>foobar</strong> happens to be <strong>null</strong> due to the bug, then your program will silently continue working incorectly, which maybe a bigger disaster. This way of error may occur much later and it would be much harder to understand at which point it went wrong.</li>
</ul>

<blockquote>
  <h3 id="java-8-interface-with-default-method">JAVA 8 INTERFACE WITH DEFAULT METHOD</h3>
</blockquote>

<ul>
  <li>Default methods help us expand interface without broken classes that implemented.</li>
  <li>Deafult methods will help us in avoiding utility classes.</li>
  <li>Default methods will help us in removing base implementabtion classes, we can provide default implementation and the implementation classes can choose which one to ooverride.</li>
  <li>If there are any class that inherit a same default method, the this default method will not be valid. The same thing is that a default method can not override a method from <strong>java.lang.object</strong> bacause <strong>Object</strong> is the base class of all classes in java. So, If we have methods in Object class which are defined as default methods in interface, the methods in Object class will be always used. This is the reason why we do not have any default methos can override methods of Object class.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// default method of interface example</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">FirstInterface</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">firstMethod</span><span class="o">(</span><span class="nc">Striing</span> <span class="n">string</span><span class="o">);</span>

    <span class="k">default</span> <span class="kt">void</span> <span class="nf">log</span><span class="o">(</span><span class="nc">String</span> <span class="n">string</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"This is the default method: "</span> <span class="o">+</span> <span class="n">string</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>As we know that, Java does not allow multi inheritances with class because the compiler does not know choose which method of super class to use. So, this happens the same for dafeult method bacause if you implement a class from 2 interface Ex: <strong>FirstInterface</strong> and <strong>SecondInterface</strong>, the compiler does not know choosing which one to execute. Multi ingeritances is a normal thing in java, we usually see this issue in java core classes, also most of enterprise and framwework application. To ensure this issue can not with interface, class has to implement common mothods default from 2 interface. So, as in the example below, class have to implement <strong>log()</strong> method for compiler can not throw exception.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// default method of first interface example</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">FirstInterface</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">firstMethod</span><span class="o">(</span><span class="nc">Striing</span> <span class="n">string</span><span class="o">);</span>

    <span class="k">default</span> <span class="kt">void</span> <span class="nf">log</span><span class="o">(</span><span class="nc">String</span> <span class="n">string</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"This is the default method: "</span> <span class="o">+</span> <span class="n">string</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// default method of second interface example</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">SecondInterface</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">secondMethod</span><span class="o">(</span><span class="nc">Striing</span> <span class="n">string</span><span class="o">);</span>

    <span class="k">default</span> <span class="kt">void</span> <span class="nf">log</span><span class="o">(</span><span class="nc">String</span> <span class="n">string</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">" default method: "</span> <span class="o">+</span> <span class="n">string</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyClass</span> <span class="n">impelemts</span> <span class="nc">FirstInterface</span><span class="o">,</span> <span class="nc">SecondInterface</span> <span class="o">{</span>
    
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">firstMethod</span><span class="o">()</span> <span class="o">{}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">secondMethod</span><span class="o">()</span> <span class="o">{}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">log</span><span class="o">(</span><span class="nc">String</span> <span class="n">string</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"MyClass logging: "</span> <span class="o">+</span> <span class="n">string</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<blockquote>
  <h3 id="java-8-interface-with-static-method">JAVA 8 INTERFACE WITH STATIC METHOD</h3>
</blockquote>

<ul>
  <li>Java interface static method is similar to default method except that we  can not override them in the implementation classes. This feature helps us in avoiding undesired results incase of poor implementation in implementation classes.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ThirdInterface</span> <span class="o">{</span>
    <span class="k">default</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">(</span><span class="nc">String</span> <span class="n">str</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(!</span><span class="n">isNull</span><span class="o">(</span><span class="n">str</span><span class="o">))</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"ThirdInterface print: "</span> <span class="o">+</span> <span class="n">str</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isNull</span><span class="o">(</span><span class="nc">String</span> <span class="n">str</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Interface null check"</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">str</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="kc">true</span> 
        <span class="o">:</span> <span class="s">""</span><span class="o">.</span><span class="na">equal</span><span class="o">(</span><span class="n">str</span><span class="o">)</span> <span class="o">?</span> <span class="kc">true</span> <span class="o">:</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ThridImpl</span> <span class="kd">implements</span> <span class="nc">ThirdInterface</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isNull</span><span class="o">(</span><span class="nc">String</span> <span class="n">str</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Impl null check"</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">str</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="kc">true</span> <span class="o">:</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//test</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span> <span class="n">args</span><span class="o">[])</span> <span class="o">{</span>
    <span class="nc">ThirdImpl</span> <span class="n">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ThirdImpl</span><span class="o">();</span>
    <span class="n">obj</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">""</span><span class="o">);</span>
    <span class="n">obj</span><span class="o">.</span><span class="na">isNull</span><span class="o">(</span><span class="s">"abc"</span><span class="o">);</span>
<span class="o">}</span>

</code></pre></div></div>
<ul>
  <li>Then we can see the results in the log as below:</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    Interface null check
    Impl null check
</code></pre></div></div>
<ul>
  <li>If we make the interface method from static to default, we will get following output:</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    Impl null check
    ThirdInterface print: abc
    Impl null check
</code></pre></div></div>

<ul>
  <li>Java interface static method is part of interface, we can not use it for implementation class objects.</li>
  <li>Java interface static methods are good for providing utility methods, for example null check, collection sorting etc.</li>
  <li>Java interface static method helps us in providing security by not allowing implementation classes to override them.</li>
  <li>We can not define static method in methods of object class, then we can get the error <strong>“this static method can not hide the instance method from Object”</strong>. This is no acceptable in java, when object is a base class for all classes, we can not have a static method and other method with the same format.</li>
  <li>We can use static methods to remove utility methods as Collections and make methods can connect to interface then we can easily find and use these methods.</li>
</ul>


    </div><a class="u-url" href="/jekyll/update/2021/02/01/java-general-part1.html" hidden></a>
  </article>
  
</div>


    </div>
  </div>
  <script src="https://unpkg.com/vanilla-back-to-top@7.2.1/dist/vanilla-back-to-top.min.js"></script>
  <script>addBackToTop()</script>
</body>
<footer><footer class="site-footer h-card">
  <div class="container">
    <div class="row">
      <div class="col-md-4">
        <h2 class="footer-heading">StepByStep</h2>
        <div>
          <div>
            <ul>
              <li>StepByStep</li><li><a class="u-email" href="mailto:minhducnguyen189@gmail.com">minhducnguyen189@gmail.com</a></li><li>&copy; 2021 Duc Nguyen. Powered by <a href="https://jekyllrb.com/">Jekyll</a></li>
            </ul>
          </div>
        </div>
      </div>
      <div class="col-md-4">
        <data class="u-url" href="/%20/"></data>
        <div><ul class="social-media-list"><li><a href="https://github.com/minhducnguyen189"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">minhducnguyen189</span></a></li><li><a href="https://www.linkedin.com/in/duc-nguyen-03109b141"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#linkedin"></use></svg> <span class="username">duc-nguyen-03109b141</span></a></li></ul>
</div>
      </div>
      <div class="col-md-4">
        
      </div>
    </div>

    <div class="row">
      <p>Hi there! Let&#39;s explore some general knowleadges and briefly definitions  in programming. I hope that this website can help people saving time in learning, also give some motivations for those who have choice the developer path.</p>
    </div>
</footer></footer>
</html>