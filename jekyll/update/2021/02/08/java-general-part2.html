<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- bootstrap library and JS, Jquery -->
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css"
    integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
  <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js"
    integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo"
    crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js"
    integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1"
    crossorigin="anonymous"></script>
  <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"
    integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM"
    crossorigin="anonymous"></script><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>General Knowledges About Java Part 2 | StepByStep</title>
<meta name="generator" content="Jekyll v4.2.1" />
<meta property="og:title" content="General Knowledges About Java Part 2" />
<meta name="author" content="Duc Nguyen" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="FINAL KEYWORD IN JAVA The final keyword in java is used to retrict the user. The java final keyword can be used in many context. Final can be variable method class The final keyword can be applied with the variables, a final variable that have no value, it is called blank final variable or uninitialized final variable. It can be initialized in the constructor only. The blank final variable can be static also which will be initialized in the static block only. If you make any variable as final, you can not change the value of final variable (It will be constant) If you make any method as final, you can not override it. If you make any class as final, you can not inherit it. HASHMAP AND HASHTABLE HashMap and Hashtable both are used to store data in key and value form. Both are using hashing technique to store unique keys. HashMap Hashtable HashMap allows one null key and multiple null values Hashtable does not allow any null key or value HashMap is non synchronized. It is not thread-safe and can not be shared between many threads without proper synchronization code Hashtable is synchronized. It is thread-safe and can be shared with many threads HashMap is fast Hashtable is slow We can make the HashMap as synchronized by calling this code: Map m = Collections.synchronizedMap(hashMap); ARRAYLIST AND LINKEDLIST ArrayList and LinkedList both implemented list interface and maintains insertion order. Both are non synchronized classes. ArrayList LinkedList ArrayList internally uses a dynamic array to store the elements LinkedList internally uses a doubly linked list to store the elemnents Manipulation with ArrayList is slow because it internally uses an array. If any element is removed from the array, all the bits are shifted in memory Manipulation with LinkedList is faster than ArrayList because it uses a doubly linked list, so no bit shifting is required in memory An ArrayList can act as a list only because it implements List only LinkedList class can act as a list and queue both because it implements List and Dequeue interfaces ArrayList is better for storing and accessing data LinkedList is better for manipulation data CHECKED AND UNCHECKED EXCEPTION IN JAVA There are 2 types of exception in java: checked and unchecked. All checked exception class are inherited from Exception class except RuntimeException. RuntimeException is the base class of all unchecked exception class, that is also a signal to recognize which one is checked exception or unchecked exception. The difference between checked and unchecked exception classes is the time to identify the exception can happen. With checked exception, checking is happened in compile time, some IDE will help us by showing syntax errors if we use a method that can throw any checked exception without try/catch. We have some checked exception: IOException, Interrupted Exception, XMLParseException… With unchecked Exception, checking exception can happen or not is only happened in the Runtime time and IDE will not help us identify it. Some popular unchecked exception: NullPointerException, IndexOutOfBoundException, ClassCastException… So, in programming the unchecked exception can be thrown in cases program have errors with logic. For errors that can be handle, the checked exception should be thrown. JAVA STATIC KEYWORD The static keyword in java is used for memory management mainly. We can apply static keyword with variable (also known as a class variable) method (also known as class method) block nested class More information STRINGBUFER AND STRINGBUILDER StringBuffer StringBuilder StringBuffer (synchronized) and thread-safe. It means there are no two threads can access to a method of StringBuffer class at the same time StringBuilder (non-synchronized) and no thread-safe. It means there are two threads can access to a method of StringBuilder class at the same time StringBuffer is low StringBuilder is fast THREAD SAFETY IN JAVA Thread safety in java is the process to make our program safe to use in multi threads environment, there are different ways through which we can make our program thread safe. Synchonization is the easiest and most widely used tool for thread safety in java. JVM guarantes that synchronized code will be excuted by only on thread at a time. Java keyword synchronized is used to create synchronized code and internally it uses locks on object or class to make sure only one thread is executing the synchronized code. Using Atomic Wrapper Classes from java.util.concurrent.atomic package Ex: AtomicInterger Using locks from java.util.concurrent.locks package Using thread safe collection classes, ex: Hashtable Using volitile keyword with variable to make every thread read the data from memory, not read from thread cache. JAVA THREADLOCAL ThreadLocal in java is another way to achieve thread-safety apart from writting immutable classes. Thread local can be considered as a scope of access like session scope or request scope. In threadlocal, you can set any object and this object will be local and global to the specific thread which is accessing this object. Java ThreadLocal class provides thread-local variables. It enables you to create variables that can only be read and write by the same thread. If two threads are executing the same code and that code has a referece to a thread ThreadLocal variable then the two threads can not see the local variable of each other. JAVA THREAD POOL Java ThreadPool represents a group of worker threads that are waiting for the job and reuse manytimes. In case of thread pool, a group of fixed size thread pool is pulled out and assigned a job by the service provider. After completeion of the job, thread is contained in the thread pool again. Advantages of java thread pool: Bester performance: It saves time because there is no need to create new thread. Thread pool is used in Servlet and JSP where container creates a thread pool to process the request. We will continue to disscus about thread pool in Spring @Async anotation." />
<meta property="og:description" content="FINAL KEYWORD IN JAVA The final keyword in java is used to retrict the user. The java final keyword can be used in many context. Final can be variable method class The final keyword can be applied with the variables, a final variable that have no value, it is called blank final variable or uninitialized final variable. It can be initialized in the constructor only. The blank final variable can be static also which will be initialized in the static block only. If you make any variable as final, you can not change the value of final variable (It will be constant) If you make any method as final, you can not override it. If you make any class as final, you can not inherit it. HASHMAP AND HASHTABLE HashMap and Hashtable both are used to store data in key and value form. Both are using hashing technique to store unique keys. HashMap Hashtable HashMap allows one null key and multiple null values Hashtable does not allow any null key or value HashMap is non synchronized. It is not thread-safe and can not be shared between many threads without proper synchronization code Hashtable is synchronized. It is thread-safe and can be shared with many threads HashMap is fast Hashtable is slow We can make the HashMap as synchronized by calling this code: Map m = Collections.synchronizedMap(hashMap); ARRAYLIST AND LINKEDLIST ArrayList and LinkedList both implemented list interface and maintains insertion order. Both are non synchronized classes. ArrayList LinkedList ArrayList internally uses a dynamic array to store the elements LinkedList internally uses a doubly linked list to store the elemnents Manipulation with ArrayList is slow because it internally uses an array. If any element is removed from the array, all the bits are shifted in memory Manipulation with LinkedList is faster than ArrayList because it uses a doubly linked list, so no bit shifting is required in memory An ArrayList can act as a list only because it implements List only LinkedList class can act as a list and queue both because it implements List and Dequeue interfaces ArrayList is better for storing and accessing data LinkedList is better for manipulation data CHECKED AND UNCHECKED EXCEPTION IN JAVA There are 2 types of exception in java: checked and unchecked. All checked exception class are inherited from Exception class except RuntimeException. RuntimeException is the base class of all unchecked exception class, that is also a signal to recognize which one is checked exception or unchecked exception. The difference between checked and unchecked exception classes is the time to identify the exception can happen. With checked exception, checking is happened in compile time, some IDE will help us by showing syntax errors if we use a method that can throw any checked exception without try/catch. We have some checked exception: IOException, Interrupted Exception, XMLParseException… With unchecked Exception, checking exception can happen or not is only happened in the Runtime time and IDE will not help us identify it. Some popular unchecked exception: NullPointerException, IndexOutOfBoundException, ClassCastException… So, in programming the unchecked exception can be thrown in cases program have errors with logic. For errors that can be handle, the checked exception should be thrown. JAVA STATIC KEYWORD The static keyword in java is used for memory management mainly. We can apply static keyword with variable (also known as a class variable) method (also known as class method) block nested class More information STRINGBUFER AND STRINGBUILDER StringBuffer StringBuilder StringBuffer (synchronized) and thread-safe. It means there are no two threads can access to a method of StringBuffer class at the same time StringBuilder (non-synchronized) and no thread-safe. It means there are two threads can access to a method of StringBuilder class at the same time StringBuffer is low StringBuilder is fast THREAD SAFETY IN JAVA Thread safety in java is the process to make our program safe to use in multi threads environment, there are different ways through which we can make our program thread safe. Synchonization is the easiest and most widely used tool for thread safety in java. JVM guarantes that synchronized code will be excuted by only on thread at a time. Java keyword synchronized is used to create synchronized code and internally it uses locks on object or class to make sure only one thread is executing the synchronized code. Using Atomic Wrapper Classes from java.util.concurrent.atomic package Ex: AtomicInterger Using locks from java.util.concurrent.locks package Using thread safe collection classes, ex: Hashtable Using volitile keyword with variable to make every thread read the data from memory, not read from thread cache. JAVA THREADLOCAL ThreadLocal in java is another way to achieve thread-safety apart from writting immutable classes. Thread local can be considered as a scope of access like session scope or request scope. In threadlocal, you can set any object and this object will be local and global to the specific thread which is accessing this object. Java ThreadLocal class provides thread-local variables. It enables you to create variables that can only be read and write by the same thread. If two threads are executing the same code and that code has a referece to a thread ThreadLocal variable then the two threads can not see the local variable of each other. JAVA THREAD POOL Java ThreadPool represents a group of worker threads that are waiting for the job and reuse manytimes. In case of thread pool, a group of fixed size thread pool is pulled out and assigned a job by the service provider. After completeion of the job, thread is contained in the thread pool again. Advantages of java thread pool: Bester performance: It saves time because there is no need to create new thread. Thread pool is used in Servlet and JSP where container creates a thread pool to process the request. We will continue to disscus about thread pool in Spring @Async anotation." />
<link rel="canonical" href="/jekyll/update/2021/02/08/java-general-part2.html" />
<meta property="og:url" content="/jekyll/update/2021/02/08/java-general-part2.html" />
<meta property="og:site_name" content="StepByStep" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-02-08T10:15:47+07:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="General Knowledges About Java Part 2" />
<script type="application/ld+json">
{"@type":"BlogPosting","url":"/jekyll/update/2021/02/08/java-general-part2.html","dateModified":"2021-02-08T10:15:47+07:00","datePublished":"2021-02-08T10:15:47+07:00","headline":"General Knowledges About Java Part 2","mainEntityOfPage":{"@type":"WebPage","@id":"/jekyll/update/2021/02/08/java-general-part2.html"},"author":{"@type":"Person","name":"Duc Nguyen"},"description":"FINAL KEYWORD IN JAVA The final keyword in java is used to retrict the user. The java final keyword can be used in many context. Final can be variable method class The final keyword can be applied with the variables, a final variable that have no value, it is called blank final variable or uninitialized final variable. It can be initialized in the constructor only. The blank final variable can be static also which will be initialized in the static block only. If you make any variable as final, you can not change the value of final variable (It will be constant) If you make any method as final, you can not override it. If you make any class as final, you can not inherit it. HASHMAP AND HASHTABLE HashMap and Hashtable both are used to store data in key and value form. Both are using hashing technique to store unique keys. HashMap Hashtable HashMap allows one null key and multiple null values Hashtable does not allow any null key or value HashMap is non synchronized. It is not thread-safe and can not be shared between many threads without proper synchronization code Hashtable is synchronized. It is thread-safe and can be shared with many threads HashMap is fast Hashtable is slow We can make the HashMap as synchronized by calling this code: Map m = Collections.synchronizedMap(hashMap); ARRAYLIST AND LINKEDLIST ArrayList and LinkedList both implemented list interface and maintains insertion order. Both are non synchronized classes. ArrayList LinkedList ArrayList internally uses a dynamic array to store the elements LinkedList internally uses a doubly linked list to store the elemnents Manipulation with ArrayList is slow because it internally uses an array. If any element is removed from the array, all the bits are shifted in memory Manipulation with LinkedList is faster than ArrayList because it uses a doubly linked list, so no bit shifting is required in memory An ArrayList can act as a list only because it implements List only LinkedList class can act as a list and queue both because it implements List and Dequeue interfaces ArrayList is better for storing and accessing data LinkedList is better for manipulation data CHECKED AND UNCHECKED EXCEPTION IN JAVA There are 2 types of exception in java: checked and unchecked. All checked exception class are inherited from Exception class except RuntimeException. RuntimeException is the base class of all unchecked exception class, that is also a signal to recognize which one is checked exception or unchecked exception. The difference between checked and unchecked exception classes is the time to identify the exception can happen. With checked exception, checking is happened in compile time, some IDE will help us by showing syntax errors if we use a method that can throw any checked exception without try/catch. We have some checked exception: IOException, Interrupted Exception, XMLParseException… With unchecked Exception, checking exception can happen or not is only happened in the Runtime time and IDE will not help us identify it. Some popular unchecked exception: NullPointerException, IndexOutOfBoundException, ClassCastException… So, in programming the unchecked exception can be thrown in cases program have errors with logic. For errors that can be handle, the checked exception should be thrown. JAVA STATIC KEYWORD The static keyword in java is used for memory management mainly. We can apply static keyword with variable (also known as a class variable) method (also known as class method) block nested class More information STRINGBUFER AND STRINGBUILDER StringBuffer StringBuilder StringBuffer (synchronized) and thread-safe. It means there are no two threads can access to a method of StringBuffer class at the same time StringBuilder (non-synchronized) and no thread-safe. It means there are two threads can access to a method of StringBuilder class at the same time StringBuffer is low StringBuilder is fast THREAD SAFETY IN JAVA Thread safety in java is the process to make our program safe to use in multi threads environment, there are different ways through which we can make our program thread safe. Synchonization is the easiest and most widely used tool for thread safety in java. JVM guarantes that synchronized code will be excuted by only on thread at a time. Java keyword synchronized is used to create synchronized code and internally it uses locks on object or class to make sure only one thread is executing the synchronized code. Using Atomic Wrapper Classes from java.util.concurrent.atomic package Ex: AtomicInterger Using locks from java.util.concurrent.locks package Using thread safe collection classes, ex: Hashtable Using volitile keyword with variable to make every thread read the data from memory, not read from thread cache. JAVA THREADLOCAL ThreadLocal in java is another way to achieve thread-safety apart from writting immutable classes. Thread local can be considered as a scope of access like session scope or request scope. In threadlocal, you can set any object and this object will be local and global to the specific thread which is accessing this object. Java ThreadLocal class provides thread-local variables. It enables you to create variables that can only be read and write by the same thread. If two threads are executing the same code and that code has a referece to a thread ThreadLocal variable then the two threads can not see the local variable of each other. JAVA THREAD POOL Java ThreadPool represents a group of worker threads that are waiting for the job and reuse manytimes. In case of thread pool, a group of fixed size thread pool is pulled out and assigned a job by the service provider. After completeion of the job, thread is contained in the thread pool again. Advantages of java thread pool: Bester performance: It saves time because there is no need to create new thread. Thread pool is used in Servlet and JSP where container creates a thread pool to process the request. We will continue to disscus about thread pool in Spring @Async anotation.","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="StepByStep" /><!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-NZ8G5007GK"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-NZ8G5007GK');
</script></head><body>
  <div class="container-flush">
    <div class="row"><!-- navigation bar -->
<div class="col-lg-12">
  <nav class="navbar navbar-expand-lg navbar-dark bg-dark" role="banner"><a class="navbar-brand site-title" rel="author" href="/">StepByStep</a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav"
      aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="navbarNav">
      <ul class="nav navbar-nav"><li class="nav-item active">
          <a class="nav-link" href="/about/">About</a>
        </li><li class="nav-item active">
          <a class="nav-link" href="/ci-cd/">CI-CD</a>
        </li><li class="nav-item active">
          <a class="nav-link" href="/database/">Database</a>
        </li><li class="nav-item active">
          <a class="nav-link" href="/docker/">Docker</a>
        </li><li class="nav-item active">
          <a class="nav-link" href="/">Java</a>
        </li><li class="nav-item active">
          <a class="nav-link" href="/python/">Python</a>
        </li></ul>
    </div><!-- Html Elements for Search -->
    <div id="search-container" class="btn-group">
      <input type="text" id="search-input" placeholder="search...">
      <button id="clear">clear</button>
      <ul id="results-container"></ul>
    </div>

    <!-- Script pointing to search-script.js -->
    <script src="/java-scripts/search-script.js" type="text/javascript"></script>

    <!-- Configuration -->
    <script>
      SimpleJekyllSearch({
        searchInput: document.getElementById('search-input'),
        resultsContainer: document.getElementById('results-container'),
        json: '/search.json'
      })
    </script>

    <!-- search clear -->
    <script>
      window.addEventListener('load', () => {
          const button = document.querySelector('#clear');
          button.addEventListener('click', () => {
              document.querySelector('#search-input').value = "";
              document.querySelector('#results-container').innerHTML = "";
          });
      }); 
  </script>
  </nav>
</div></div>
  </div>

  <div class="container">
    <div class="row">
      <div class="col-lg-8 mx-auto">
  <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
    <header class="post-header">
      <h1 class="post-title p-name" itemprop="name headline">General Knowledges About Java Part 2</h1>
      <p class="post-meta">
        <time class="dt-published" datetime="2021-02-08T10:15:47+07:00" itemprop="datePublished">Feb 8, 2021
        </time></p>
    </header>
  
    <div class="post-content e-content" itemprop="articleBody">
      <h2 id="final-keyword-in-java">FINAL KEYWORD IN JAVA</h2>

<ul>
  <li>The <code class="language-plaintext highlighter-rouge">final</code> keyword in java is used to retrict the user. The java <code class="language-plaintext highlighter-rouge">final</code> keyword can be used in many context. Final can be
    <ul>
      <li>variable</li>
      <li>method</li>
      <li>class</li>
    </ul>
  </li>
  <li>The final keyword can be applied with the variables, a final variable that have no value, it is called <strong>blank final variable</strong> or <strong>uninitialized final variable</strong>. It can be initialized in the constructor only. The <strong>blank final</strong> variable can be <strong>static</strong> also which will be initialized in the <strong>static block only</strong>.
    <ul>
      <li>If you make any <strong>variable</strong> as final, you can not change the value of final variable (It will be constant)</li>
      <li>If you make any <strong>method</strong> as final, you can not override it.</li>
      <li>If you make any <strong>class</strong> as final, you can not inherit it.</li>
    </ul>
  </li>
</ul>

<h2 id="hashmap-and-hashtable">HASHMAP AND HASHTABLE</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">HashMap</code> and <code class="language-plaintext highlighter-rouge">Hashtable</code> both are used to store data in <strong>key and value</strong> form. Both are using hashing technique to store unique keys.</li>
</ul>

<table>
  <thead>
    <tr>
      <th>HashMap</th>
      <th>Hashtable</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">HashMap</code> allows one null key and multiple null values</td>
      <td><code class="language-plaintext highlighter-rouge">Hashtable</code> does not allow any null key or value</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">HashMap</code> is <strong>non synchronized</strong>. It is <strong>not thread-safe</strong> and can not be shared between many threads without proper <strong>synchronization</strong> code</td>
      <td><code class="language-plaintext highlighter-rouge">Hashtable</code> is <strong>synchronized</strong>. It is <strong>thread-safe</strong> and can be shared with many threads</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">HashMap</code> is fast</td>
      <td><code class="language-plaintext highlighter-rouge">Hashtable</code> is slow</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>We can make the <code class="language-plaintext highlighter-rouge">HashMap</code> as <strong>synchronized</strong> by calling this code:</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Map</span> <span class="n">m</span> <span class="o">=</span> <span class="nc">Collections</span><span class="o">.</span><span class="na">synchronizedMap</span><span class="o">(</span><span class="n">hashMap</span><span class="o">);</span> 
</code></pre></div></div>

<h2 id="arraylist-and-linkedlist">ARRAYLIST AND LINKEDLIST</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">ArrayList</code> and <code class="language-plaintext highlighter-rouge">LinkedList</code> both implemented list interface and maintains insertion order. Both are <strong>non synchronized</strong> classes.</li>
</ul>

<table>
  <thead>
    <tr>
      <th>ArrayList</th>
      <th>LinkedList</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ArrayList</code> internally uses a <strong>dynamic array</strong> to store the elements</td>
      <td><code class="language-plaintext highlighter-rouge">LinkedList</code> internally uses a <strong>doubly linked list</strong> to store the elemnents</td>
    </tr>
    <tr>
      <td>Manipulation with <code class="language-plaintext highlighter-rouge">ArrayList</code> is <strong>slow</strong> because it internally uses an array. If any element is removed from the array, all the bits are shifted in memory</td>
      <td>Manipulation with <code class="language-plaintext highlighter-rouge">LinkedList</code> is <strong>faster</strong> than <code class="language-plaintext highlighter-rouge">ArrayList</code> because it uses a doubly linked list, so no bit shifting is required in memory</td>
    </tr>
    <tr>
      <td>An <code class="language-plaintext highlighter-rouge">ArrayList</code> can act as a <strong>list</strong> only because it implements <strong>List</strong> only</td>
      <td><code class="language-plaintext highlighter-rouge">LinkedList</code> class can act as a <strong>list</strong> and <strong>queue</strong> both because it implements <strong>List</strong> and <strong>Dequeue</strong> interfaces</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ArrayList</code> is better for storing and accessing data</td>
      <td><code class="language-plaintext highlighter-rouge">LinkedList</code> is better for manipulation data</td>
    </tr>
  </tbody>
</table>

<h2 id="checked-and-unchecked-exception-in-java">CHECKED AND UNCHECKED EXCEPTION IN JAVA</h2>
<ul>
  <li>There are 2 types of exception in java: <strong>checked</strong> and <strong>unchecked</strong>. All <code class="language-plaintext highlighter-rouge">checked exception</code> class are inherited from <strong>Exception</strong> class except <strong>RuntimeException</strong>. <strong>RuntimeException</strong> is the base class of all <code class="language-plaintext highlighter-rouge">unchecked exception</code> class, that is also a signal to recognize which one is checked exception or unchecked exception.</li>
</ul>

<p><a href="/assets/images/checked-unchecked-exception.png"><img src="/assets/images/checked-unchecked-exception.png" alt="checked and unchecked exception" title="checked and unchecked exception" /></a></p>

<ul>
  <li>The difference between <strong>checked</strong> and <strong>unchecked</strong> exception classes is the time to identify the exception can happen. With <strong>checked exception</strong>, checking is happened in <strong>compile time</strong>, some IDE will help us by showing syntax errors if we use a method that can throw any <strong>checked exception</strong> without try/catch. We have some checked exception: <code class="language-plaintext highlighter-rouge">IOException</code>, <code class="language-plaintext highlighter-rouge">Interrupted Exception</code>, <code class="language-plaintext highlighter-rouge">XMLParseException</code>… With <strong>unchecked Exception</strong>, checking exception can happen or not is only happened in the <strong>Runtime</strong> time and IDE will not help us identify it. Some popular <strong>unchecked exception</strong>: <code class="language-plaintext highlighter-rouge">NullPointerException</code>, <code class="language-plaintext highlighter-rouge">IndexOutOfBoundException</code>, <code class="language-plaintext highlighter-rouge">ClassCastException</code>…</li>
  <li>So, in programming the <strong>unchecked exception</strong> can be thrown in cases program have errors with logic. For errors that can be handle, the <strong>checked exception</strong> should be thrown.</li>
</ul>

<h2 id="java-static-keyword">JAVA STATIC KEYWORD</h2>
<ul>
  <li>The <code class="language-plaintext highlighter-rouge">static</code> keyword in java is used for memory management mainly. We can apply <code class="language-plaintext highlighter-rouge">static</code> keyword with
    <ul>
      <li>variable (also known as a class variable)</li>
      <li>method (also known as class method)</li>
      <li>block</li>
      <li>nested class</li>
    </ul>
  </li>
  <li><a href="https://www.javatpoint.com/static-keyword-in-java">More information</a></li>
</ul>

<h2 id="stringbufer-and-stringbuilder">STRINGBUFER AND STRINGBUILDER</h2>

<table>
  <thead>
    <tr>
      <th>StringBuffer</th>
      <th>StringBuilder</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">StringBuffer</code> (<strong>synchronized</strong>) and <strong>thread-safe</strong>. It means there are no two threads can access to a method of <code class="language-plaintext highlighter-rouge">StringBuffer</code> class at the same time</td>
      <td><code class="language-plaintext highlighter-rouge">StringBuilder</code> (<strong>non-synchronized</strong>) and <strong>no thread-safe</strong>. It means there are two threads can access to a method of <code class="language-plaintext highlighter-rouge">StringBuilder</code> class at the same time</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">StringBuffer</code> is <strong>low</strong></td>
      <td><code class="language-plaintext highlighter-rouge">StringBuilder</code> is <strong>fast</strong></td>
    </tr>
  </tbody>
</table>

<h2 id="thread-safety-in-java">THREAD SAFETY IN JAVA</h2>
<ul>
  <li>Thread safety in java is the process to make our program safe to use in multi threads environment, there are different ways through which we can make our program thread safe.</li>
  <li><strong>Synchonization</strong> is the easiest and most widely used tool for thread safety in java. JVM guarantes that <strong>synchronized code</strong> will be excuted by only on thread at a time. Java keyword <code class="language-plaintext highlighter-rouge">synchronized</code> is used to create <strong>synchronized code</strong> and internally it uses <strong>locks</strong> on object or class to make sure only one thread is executing the synchronized code.</li>
  <li>Using Atomic Wrapper Classes from <strong>java.util.concurrent.atomic</strong> package Ex: <code class="language-plaintext highlighter-rouge">AtomicInterger</code></li>
  <li>Using locks from <strong>java.util.concurrent.locks</strong> package</li>
  <li>Using thread safe collection classes, ex: <code class="language-plaintext highlighter-rouge">Hashtable</code></li>
  <li>Using volitile keyword with variable to make every thread read the data from memory, not read from thread cache.</li>
</ul>

<h2 id="java-threadlocal">JAVA THREADLOCAL</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">ThreadLocal</code> in java is another way to achieve thread-safety apart from writting immutable classes. Thread local can be considered as a scope of access like session scope or request scope. In threadlocal, you can set any object and this object will be local and global to the specific thread which is accessing this object.</li>
  <li>Java <code class="language-plaintext highlighter-rouge">ThreadLocal</code> class provides thread-local variables. It enables you to create variables that can only be read and write by the same thread. If two threads are executing the same code and that code has a referece to a thread <code class="language-plaintext highlighter-rouge">ThreadLocal</code> variable then the two threads can not see the local variable of each other.</li>
</ul>

<h2 id="java-thread-pool">JAVA THREAD POOL</h2>
<ul>
  <li>Java <code class="language-plaintext highlighter-rouge">ThreadPool</code> represents a group of worker threads that are waiting for the job and reuse manytimes. In case of thread pool, a group of fixed size thread pool is pulled out and assigned a job by the service provider. After completeion of the job, thread is contained in the thread pool again.</li>
  <li>Advantages of java thread pool:
    <ul>
      <li>Bester performance: It saves time because there is no need to create new thread.</li>
      <li>Thread pool is used in Servlet and JSP where container creates a thread pool to process the request.</li>
    </ul>
  </li>
</ul>

<p><a href="/assets/images/threadpool.jpg"><img src="/assets/images/threadpool.jpg" alt="thread pool" title="thread pool" /></a></p>
<ul>
  <li>We will continue to disscus about thread pool in Spring <code class="language-plaintext highlighter-rouge">@Async</code> anotation.</li>
</ul>

    </div><a class="u-url" href="/jekyll/update/2021/02/08/java-general-part2.html" hidden></a>
  </article>
  
</div>


    </div>
  </div>
  <script src="https://unpkg.com/vanilla-back-to-top@7.2.1/dist/vanilla-back-to-top.min.js"></script>
  <script>addBackToTop()</script>
</body>
<footer><footer class="site-footer h-card">
  <div class="container">
    <div class="row">
      <div class="col-md-4">
        <h2 class="footer-heading">StepByStep</h2>
        <div>
          <div>
            <ul>
              <li>Duc Nguyen</li><li><a class="u-email" href="mailto:minhducnguyen189@gmail.com">minhducnguyen189@gmail.com</a></li><li>&copy; 2021 Duc Nguyen. Powered by <a href="https://jekyllrb.com/">Jekyll</a></li>
            </ul>
          </div>
        </div>
      </div>
      <div class="col-md-4">
        <data class="u-url" href="/%20/"></data>
        <div><ul class="social-media-list"><li><a href="https://github.com/minhducnguyen189"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">minhducnguyen189</span></a></li><li><a href="https://www.linkedin.com/in/duc-nguyen-03109b141"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#linkedin"></use></svg> <span class="username">duc-nguyen-03109b141</span></a></li></ul>
</div>
      </div>
      <div class="col-md-4">
        
      </div>
    </div>

    <div class="row">
      <p>Hi there! Let&#39;s explore some general knowleadges and briefly definitions  in programming. I hope that this website can help people saving time in learning, also give some motivations for those who have choice the developer path.</p>
    </div>
</footer></footer>
</html>